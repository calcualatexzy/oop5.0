### 文件和流

读操作在流数据抽象中被称为（从流中）**提取**，写操作被称为（向流中）**插入**。

**输出流**：表示数据从内存传送到某个载体或设备中；

**输入流**：数据从某个载体或设备传送到内存缓冲区变量中；

![1687442360589](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1687442360589.png)

iostream包含了对输入输出流进行操作所需的基本信息。

fstream用于用户管理的文件的I/O操作。

strstream用于字符串流I/O。

stdiostream用于混合使用C和C++的I/O机制时。

iomanip在使用格式化I/O时应包含此头文件。

##### 输入输出流分类：1.标准流；2.文件流；3.字符串流

#### 标准输入流：

##### 使用cin进行输入

istream类的对象，它从标准输入设备(键盘)获取数据

程序中的变量通过流提取符“>>”从流中提取数据。

在istream流类重载>>的一组公用成员函数

```c++
istream& operator >>（基本类型标识符&）；
```

流提取符从流中提取数据时通常跳过输入流中的空格、tab键、换行符等空白字符。

输入运算符>>也支持级联输入。在默认情况下，运算符>>跳过空格，读入后面与变量类型相应的值。

当**输入字符串(char* 类型)**时，输入运算符>>会跳过空格，读入后面的非空格符，**直到遇到另外一个空格结束**，并在字符串末尾自动放置字符‘\0’作为结束标志，例如:

```c++
char s[20];

cin>>s;
```

当输入：Hello!  world! 时，存储在字符串s中的值为“Hello!”，而没有后面的“world!”。

数据输入时，不仅检查数据间的空格，还做类型检查、自动匹配。

istream类的公有成员函数：

| **函数**       | **功能**                               |
| -------------- | -------------------------------------- |
| **read**       | **无格式输入指定字节数**               |
| **get**        | **从流中提取字符，包括空格**           |
| **getline**    | **从流中提取一行字符**                 |
| **ignore**     | **提取并丢弃流中指定字符**             |
| **peek**       | **返回流中下一个字符，但不从流中删除** |
| **gcount**     | **统计最后输入的字符个数**             |
| **eatwhite**   | **忽略前导空格**                       |
| **seekg**      | **移动输入流指针**                     |
| **tellg**      | **返回输入流中指定位置的指针值**       |
| **operstor>>** | **提取运算符**                         |

int istream::get()

如果输入流包括附加的数据，函数取得并返回下一个字符；否则它返回EOF。

istream& istream::get(char &c)

如果输入流包括附加的数据，函数取得并将下一个字符分配给c；否则就是没有定义对c的作用。返回一个对*this（调用对象）的引用。

istream& istream::get(char s[],int n,char delim='\n')

从输入流获取字符并将它们分配给s直到下面的一个条件发生：取得n-1个字符，没有输入字符了，或者下一个接收的字符的值为delim。

istream& istream::getline(char s[],int n,char delim='\n')

从输入流获取字符并将它们分配给s直到下面的一个条件发生：取得n-1个字符，没有输入字符了，或者下一个接收的字符的值为delim。

int istream::peak()

如果输入流包括附加的数据，函数返回下一个接收的字符；否则它返回EOF。

istream& istream::unget(char c)

字符c被送到输入流。它将是下一个要接收的字符。函数返回一个对*this的引用。

库iostream还提供对ios成员函数的访问，一些程序在输入流中检测文件尾。

bool ios::eof()

如果流中达到文件尾则返回真；否则函数返回假。

##### 使用get()方法输入：

istream类中的get()方法提供不跳过空格的单字符输入功能。使用方式为：

输入流对象.get(字符型变量)

```c++
int a=0;
	char ch;
	cin.get(ch);
	while(ch!='\n')
	{
		cout<< ch;
		a++;
		cin.get(ch);
	}
```

假如输入了：I can do. 

按下回车键后，get(ch)首先从输入流中读取字符I，存储在ch中，使用cout显示它，再将a加1。然后，读取I后面的空格字符，存储，显示，让a加1.这样依次循环，直到读取到回车键，终止循环。

get方法还有三种重载形式：1.无参数的；2.有两个参数；3.有三个参数的

**无参数**的get()方法用于从指定的输入流中提取一个字符（包括空格），函数的返回值为读入的字符。例如：

```c++
char ch;

ch=cin.get();
```

**有两个参数**的get()方法，其原型如下：

```c++
istream & get(char *, int);
```

其中，第一个参数用于放置字符串的内存单元的地址。第二个参数为读取的最大字符数（额外的一个字符用于存储结尾的空字符，因此只能读取最大字符数-1个字符）。例如：

```c++
char line[50];

cin.get(line,50);
```

cin.get()函数将在到达第49个字符或遇到换行符后停止将输入读取到数组中。

**有三个参数**的get()方法，其原型如下：

```c++
istream & get(char *, int,char);
```

其中，前两个参数与上面的相同，**第三个参数指定用作分界符的字符。只有两个参数的get()函数将换行符用作分界符**。例如：

```c++
char line[50];

cin.get(line,50，’#’);
```

假如输入了Please give me #3 apples.由于get()函数将字符‘#’为分界符，所以储存到line数组只有Please give me 。

##### 使用getline()方法输入：

istream类中的getline()方法可以读取整行输入，而不是一个字符。使用方法为：

```c++
输入流对象**.**getline**(**字符指针，字符个数)
```

字符指针用来放置输入字符串的内存单元的地址。字符个数用来限制读取的最大字符数。由于存储字符串额外需要存储一个结尾的空字符，读取的最大字符数为字符个数-1。

getline()重载方法同样也有三个参数的方法,三个参数的作用和上面get()方法类似，其原型如下：

```c++
istream & getline(char *, int,char);
```

##### 使用read()方法输入：

istream类中的read()方法读取指定数目的字节，并将它们存储在指定的位置中。

例如，下面的语句从标准输入流中读取25个字符，并将它们存储在数组a中：

```c++
  char a[50];
  cin.read(a,25);
```

与getline()和get()不同的是，read()**不会在输入后加上空值字符**，因此不能将输入转换为字符串。该方法的返回类型为istream &，因此可以像下面拼接起来：

```c++
char a[50];
char b[100]
cin.read(a,50).read(b,100);
```

#### 标准输出流：

##### 使用cout进行输出：

利用<<输出的时候需要注意优先级的问题，例如求两者中的最大值问题：

```c++
int i=10,j=20;
cout<<"the max is ";
cout<<(i>j)?i:j；
```

程序的输出结果为：the max is 0 .

由于 *<<* 运算符的优先级高于条件运算符(?:),所以需要使用圆括号包围条件表达式。

ostream& ostream::put(char c)

将字符c插入输入流中。函数返回一个对*this的引用。

ostream& ostream::write(const char s[],int n)

将s中的n个字符插入到输入流中。空字符也是有效的。函数返回一个对*this的引用。

ostream& ostream::flush()

强制任何没有完成的操作符插入完成。函数返回一个对*this的引用。

##### 使用put()方法输出：

ostream类中put()方法用于输出一个字符，其原型如下：

ostream & put(char);

可以用类方法表示法来调用它：

cout.put('A');

其中，cout是调用方法的对象，put()是类成员函数。和<<运算符函数一样，该函数也返回一个指向调用对象的引用，因此实现拼接输出：

**cout.put('O').put('K');**

##### 使用write()方法输出：

ostream类中write()方法用于显示字符串，其原型：

ostream & write (const char* s , streamsize n);

write()的第一个参数是指向char型的指针，第二个参数指出显示字符的数量。write()方法**不会在遇到空字符时自动停止输出字符，而会按照指定数量输出字符，即使超出了字符串的边界。如果超出了字符串的边界，程序会将字符串在内存中存储位置后面数据输出。**



格式化控制

##### 输出宽度：

为了调整输出时的显示宽度，可以通过调用width成员函数为每个项（item）指定输出宽度或在流中放入setw操纵符。

##### 对齐方式：

输出流的默认对齐方式为文本右对齐，程序中可以用setiosflags和resetiosflags操作符重设对齐方式。 

##### 精度：

使用setprecision操作符改变精度，该操作符有两个标志，ios::fixed和ios::scientific。 

##### 进制：

可以用dec、oct和hex操纵符设置输入和输出的默认进制。 



#### 标准错误输出流

##### cerr（无缓冲标准错误输出流）  

cerr与cout的差别在于：

cerr不能重定向，只能输出到显示器；

cerr不能被缓冲，直接输出到显示器

​       cerr << “Error” << “\n”;

##### clog（有缓冲标准错误输出流）  

clog 与 cerr区别：

clog能被缓冲，缓冲区满时输出。



#### 文件的输入和输出

##### C++将文件流分为3类：

  （1）ifstream流类，是从istream类派生的，用于文件的输入操作；

  （2）ofstream 流类，是从ostream类派生的，用于文件的输出操作；

  （3）fstream 流类，是从iostream类派生的，用于文件的输入和输出操作。

将数据输入输出到文件中，除了可以使用write和read函数外，还可以使用“<<”和“>>”运算符，而所有前面提及的格式控制方法，均可以在文件I/O中使用。

在二进制模式下，文件的I/O将利用write和read函数将所有数据以字节形式储存至文件里。

对于原本就是字符的数据，并不需要转型，即可读取/写入到文件里；但对于数字型的数据，则必须转为字符指针，然后传入write和read函数。

##### 文件的打开与关闭：

fstream类可以用于将数据写入文件，或读取文件的数据。要使用fstream类执行文件的I/O时，首先必须先定义一个fstream类的对象。例如：

```c++
fstream   file;   // 定义一个fstream对象
```

文件在进行读写操作前，应先打开，其目的是为文件流对象和特定的外存文件建立关联，并指定文件的操作方式。打开文件的方式有以下两种。

1.使用open()函数。

open函数是ifstream、ofstream和fstream类的成员函数。文件打开方式的一般格式为：

```c++
文件流对象名.open("文件名"，打开模式)；
```

2.使用构造函数。

使用构造函数同样也可以打开文件，与open()函数实现的功能一样。由于不同的输入输出类，其使用的格式分别为：

```c++
ifstream 对象名("文件名","打开方式");

ofstream 对象名("文件名","打开方式");

fstream 对象名("文件名","打开方式");
```



当对一个文件的读写操作完成后，为了保证数据安全，切断文件与流的联系，应及时关闭文件。关闭文件的一般格式为：

```
     流对象名.close( )
```

注意：关闭这样的连接并不会删除流，而只是断开流与文件的连接。而流对象还仍然存在，并可以重新连接到同一个文件或另一个文件。