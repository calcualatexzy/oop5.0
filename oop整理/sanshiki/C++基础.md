# C++ 基础

## C++程序组成部分
注释、编译预处理和程序主体

*   类声明文件(.h)
*   类实现文件(.cpp)
*   类使用文件(main.cpp)

## 命名空间
避免大规模程序设计中不同模块或者函数库中相同标识符命名冲突
使用对应命名空间：`using namespace namesp`

```cpp
//命名空间定义
namespace mynamesp
{
    //成员声明
    int a;
    double func();
}
```
```cpp
//命名空间外
double mynamesp::func();
```
**注意**
*   命名空间标识符名所在定义的域中必须是唯一的
*   命名空间作用域不能以分号结束
*   命名空间可以在全局作用域或其他作用域（另一个命名空间）内定义，但不能在函数或类内定义
*   成员都是公有的，不能私有化

## 输入输出数据流

C++字符串：
-   `#include <string>`
-   赋值方法：
    -   `string str1 = “hello”`
    -   `string str2[] = {“111”,”222”}`
    -   可以直接用关系运算符对字符串进行比较

### 输出流
cout：
-   `<<`：将紧随其后的双引号内的字符原样输出到标准输出设备上
-   `endl`：输出换行，刷新缓冲区
-   `cout.put(char)`：输出一个字符
-   `cout.write(const char*,num)`：输出指定字符，即使越界

### 输入流
cin:
-   `cin >> variable`:读入数据
-   原则上是系统内置的简单数据类型
-   后面只能出现变量名
-   `cin.get(varible)`：不跳过空格的单字符输入
-   `cin.getline(char_pointer,num)`：整行输入
-   `cin.read(char_pointer,num)`：读取指定字节
-   迭代输入：`cin.get().get()`,`cin.read().read()`

### 格式化控制
在iomanip头文件中
```
resetiosflags:清除lFlags
setiosflags:设置lFlags
setbase(int base):设置基数，base=8,10,16
setfill(char c):设置填充符
setprecision(int n):设置浮点数精度
setw(int n):设置输出宽度
```

### 错误输出流
`cerr`：无缓冲错误输出流
`clog`：有缓冲错误输出流

## 引用
引用是一个对象（变量）的别名，用符号&来定义。

在**变量声明**时出现的&才是引用运算符！其他地方都是地址运算符！
例：
```
int m;
int &n = m;     //引用
cout << &m << endl;     //地址
```
注意事项：
-   不能建立引用的引用
-   不能建立引用数组`int &ib[6]`，也不能建立数组的引用`int &bb = b`
-   可以建立指针的引用，但不能创建指向引用的指针。
    ```
    int a;
    int &*ap = a;   //错误，是指向引用的指针
    int *pa = &a;
    int *&pr = pa;  //正确，是指针的引用
    ```
### 引用在函数中的用法

#### 传入引用
像指针一样修改原变量。

#### 返回引用
实际上是返回了变量的地址。返回值可以作为左值。

**注意**：当返回引用时，不可以return一个表达式。
```cpp
int& add(int x, int y)
{
    return x+y; //错误，不能返回表达式作为引用
}
```    

    
## 函数

### 默认参数
可以在函数声明或定义时给参数指定默认值，如果没有提供实际参数，则取默认值。

注意事项：
-   如果函数既有声明也有定义，则默认参数只能在原型声明中指定。
-   在函数原型中，所有取默认值的参数都**必须**出现在不取默认值参数的**右侧**。从某个参数开始，右面所有的参数都必须有默认值。
-   不允许某个参数省略后再给右侧的参数指定参数值。`add(,8,4)`
-   注意避免二义性（重载时会出现）。`int add(int x,int y=1)`和`int add(int x)`    

### 函数重载
两个或两个以上函数具有相同的函数名，但参数类型不一致或参数个数不同。
编译时编译器将根据实参和形参的类型以及个数进行相应的匹配，自动确定调用哪个函数。

注意事项：
-   必须具有不同的参数个数或不同的参数类型，若只是返回值的类型不同或形参名不同是错误的。`float func()`和`int func()`不算重载。
-   匹配顺序：首先寻找一个精确匹配，然后通过内部类型转换（窄到宽，如int到float）找匹配，最后通过强制类型转换找匹配。
-   注意二义性：`int f(int &x)`和`int f(int x)`属于重载，但是编译器无法识别。

### 内联函数
对于功能简单、规模小、使用频繁的函数可以设置为内联函数。在编译时，编译器直接用内联函数的代码代替内联函数。
本质：空间换时间

注意事项：
-   内联函数不能有循环、switch和递归。
-   声明必须出现在第一次被调用之前。
-   类内定义的成员函数默认定义为内联函数。

## 变量作用域和生存期
函数原型作用域、块作用域、类作用域、文件作用域（全局）、命名空间作用域……

静态生存期：与程序运行期相同。static、全局

## const常量
-   常量不能作为左值
-   必须在定义的时候初始化。

和`#define`相比：define只是替换字符，没有数据类型。

## 动态内存分配和释放

### 程序数据存储区 

*   程序代码区：存放代码
*   静态区：存放常量、静态变量、全局变量
*   动态区（堆栈）
    *   栈区由编译器自动分配释放，存放局部变量、函数参数及返回值、临时变量。
    *   堆区：程序中存在空闲存储单元（自由存储单元），由程序员进行申请分配释放。
### 堆区内存分配释放

#### new
语法：（其中p均为指针变量）
-   `p = new T;`
-   `p = new T(初始值列表);`
-   `p = new T[元素个数];`**这里的数组不能进行初始化！**

**注意：** new申请的空间只能由delete释放

#### delete
语法：
-   `delete p`
-   `delete[] p` 释放动态分配的数组存储区

## 文件输入输出

### 文件的打开和关闭
定义文件流对象：
```cpp
ifstream ifile;
ofstream ofile;
```
打开文件：`file.open(string addr,open_mode)`
判断是否打开：`file.is_open()`
打开模式：
*   `ios::in`打开输入文件
*   `ios::out`打开输出文件
*   `ios::app`追加
……
关闭文件：`file.close()`

### 文件的输入和输出
```cpp
ofile << x; //输出
ifile >> x;//输入
```

必考：
*   构造析构函数
*   基类继承类构造析构
*   模版类
*   异常处理（只管一个catch）
*   引用（声明同时必须附上名字，不允许再赋值）
*   强制类型转换符（稍微看）
*   控制域