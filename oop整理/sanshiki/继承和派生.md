# 继承和派生

## 继承方式

-   公有继承（public）：
    -   不改变父类中的访问权限
-   保护继承（protected）：
    -   将public转为protected
-   私有继承（private）：
    -   将public,protected转为priate

总结：向下兼容

子类可以访问基类中的公有和保护成员。

## 兼容性

### 同名成员
派生类中的成员可以覆盖基类的同名成员。

### 访问声明
调整个别成员，使之保持原来的访问属性
```cpp
class X
{
    public:
        int a;
        void func();
};
class Y : private X
{
    public:
        X::func();  //访问声明
        X::a;
}
```

## 派生类的构造函数和析构函数
构造函数和析构函数不能被继承，需要在派生类中重新定义。

派生类需要完成基类成员的初始化，可以调用基类构造函数。

构造函数执行顺序
-   **先**调用基类构造函数，再堆新加成员初始化
-   先祖先（基类），再客人（内嵌对象），最后自己
析构函数执行顺序
-   先自己，再客人，最后祖先

```cpp
class A
{
    public:
        int data;
        A(int d) : data(d) {}
};
class sonOfA
{
    public:
        sonOfA(int d) : A(d) {}
}
```

## 多重继承
```cpp
classB : public A1,public A2,public A3;
```

### 多重继承的二义性

#### 同名成员
派生类的不同基类有同名成员产生二义性

消除方法：
1、使用作用域标识符。
```cpp
c1.A::f();
c1.B::f();
```
2、在派生类中重新定义，使用同名覆盖原则。

#### 引用公共基类成员
派生类的多个父类具有同一个父类（菱形继承）。
```cpp
class L1 {int a;}
class L2_1 : public L1;
class L2_2 : public L1;
class L3 : public L2_1,public L2_2;

L3 obj3;
obj3.a;  //二义性
obj3.L1::a;  //二义性
obj3.L2_1::a;    //正确
```

消除方法：
1、使用作用域标识符

2、虚基类
L3同时具有L1的两份拷贝，增加了内存开销。
解决办法：将共同基类设置为虚基类。
```cpp
//将L1设计为虚基类
class L2_1 : virtual public L1;
class L2_2 : virtual public L1;
```
注意：
-   虚基类关键字的作用范围只是对紧跟其后的基类起作用
-   进一步派生过程中，虚基类成员和派生类一起维护同一份内存数据拷贝
-   任何直接或间接继承虚基类的所有派生类都**必须**在初始化列表中给出对**虚基类**的初始化。
-   存在多个虚基类，初始化顺序由继承结构中的位置决定（从上到下、从左到右）
-   在派生类中调用虚基类的构造函数后，如果在其父类**再次调用**虚基类的构造函数，则这一次调用**不起作用**。（虚基类相当于内部有一个标志说，这个类已经构造过一次了）

## 子类型于赋值兼容规则

B是A的子类型：B包含所有A的功能，能够用于A类型能使用的所有场合（B：派生类）
-   派生类对象可以赋值给基类对象
-   派生类对象可以用于初始化基类的引用
-   派生类对象指针可以赋值给基类对象指针