### 多态性

多态性的实现方式有4种：**重载多态**、**强制多态**、**类型参数化多态**和**包含多态**。

**关联(binding)**：指把一个标识符和一个存储地址联系起来。分为静态关联和动态关联。

**静态(早期)关联**：编译时能确定具体的调用对象。反之为**动态(滞后)关联**。

**静态多态**：编译时的多态性，通过函数的重载实现。

**动态多态**：运行时的多态性，基类指针变量线指向某一类对象，然后通过此指针变量调用该对象中的虚函数。

#### 运算符重载

运算符重载实质上是将运算对象转化为运算函数的实参，并根据实参的类型来确定重载的运算函数。

##### 函数类型  operator  运算符名称（形参列表）{对运算符的重载处理}

eg.  Complex  operator +(Complex  &a,  Complex  &b);

##### 重载运算符的规则：

1.不能定义新的运算符；2.并非所有运算符均能重载；3.操作符允许的操作个数、优先级和结合性不能变；4.运算符重载函数不能有默认参数，否则就是改变了参数个数；5.重载的操作符必须有一个用户自己定义的类型作为操作数；6.‘=’、‘&’、‘，’运算符自动拥有重载；

##### 不能重载的运算符：

**.**(成员访问运算符)，**.***(成员指针访问运算符)，**::**(域运算符)，**sizeof**(长度运算符)，**?:**(条件运算符)

##### 运算符重载的两种形式：1.类的函数成员；2.类的友元函数

Complex  operator+(Complex  &b);

friend  Complex  operator+(Complex  &a,  Complex  &b);

##### 必须重载为某个类的成员函数：=、[]、()、->

##### 必须重载为普通函数或友元函数：>>、<<

一般而言，双目运算符重载为友元函数，单目运算符重载为成员函数

单目运算符重载为成员函数时可省略参数（即没有参数）。

##### 重载流掺入运算符和流提取运算符：

istream  &operator>>(istream &, 自定义类&);

ostream  &operator<<(ostream &, 自定义类&);

##### 下标运算符[]的重载：

返回类型  类名::operator[](形参){}

##### 函数调用运算符()的重载：



#### 不同类型间的转换

1.标准类型数据间的转换；2.用转换构造函数实现；3.类型转换函数；

##### 转换运算符函数与其他重载运算符函数有两点不同：

第一，转换运算符函数无需实参；

第二，转换运算符函数没有返回类型，甚至void 也不行。可以根据转换运算符函数的名字推出函数的返回类型，例如，如果要将一个time24对象转换为int类型，则在类中定义该转换运算符函数的名字为operator int。

#### 虚函数

virtual 函数类型  函数名(参数表);

虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过**基类指针或引用**来访问派生类中的同名函数。

##### 虚函数规则：

（1）只有成员函数才能声明为虚函数，因为虚函数仅适用于有继承关系的类对象，所以普通函数和友元函数都不能声明为虚函数。

（2）虚函数的声明只能出现在类声明中的函数原型声明或定义中，在类外定义时不能出现virtual关键字。

（3）通过定义虚函数来使用C++语言提供的多态性机制时，派生类应该是从基类公有派生的。

（4）类的静态成员函数不可以声明为虚函数，因为静态成员函数不受限于某个对象。

（5）类的构造函数不可以是虚函数。虚函数是为了实现动态多态性，根据不同的对象在运行过程中才能决定和哪个函数建立关联，而构造函数是在对象创建时运行的，故虚构造函数是没有意义的。

（6）析构函数可以声明为虚函数，而且通常被声明为虚函数。

（7）内联函数不能声明为虚函数，因为内联函数不能在运行中动态确定其位置。

（8）基类的虚函数无论被公有继承多少次，在多级派生类中仍然为虚函数。

##### 虚函数与重载函数间的关系：

一般的函数重载时，只要函数名相同，函数的参数个数、参数类型或顺序必须不同，函数的返回类型也可以不同。但是，当重载一个虚函数时，也就是说在派生类中重新定义此虚函数时，要求函数名、返回类型、参数个数、参数类型以及参数的顺序都必须与基类中的虚函数原型完全相同。如果仅仅是返回类型不同，其余均相同，系统会给出错误信息；若仅仅是函数名相同，而参数的个数、类型或顺序不同，则系统将它作为普通的函数重载，这时将丢失虚函数的特性。

虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数。实现动态关联需要3个条件：

（1）必须把需要动态关联的行为定义为类的公共属性的虚函数；

（2）类之间存在子类型关系，一般表现为一个类从另一个类公有派生而来；

（3）必须先使用基类指针指向子类型的对象，然后直接或者间接使用基类指针调用虚函数。

实现动态关联，只能通过指向**基类的指针或基类对象**的引用来调用虚函数，其格式如下：

（1）指向**基类**的指针变量名->虚函数名（实参表）

（2）**基类**对象的引用名.虚函数名（实参表）

##### 虚析构函数：

当派生类的对象从内存中撤销时一般先运行派生类的析构函数，然后再调用基类的析构函数。如果用new运算符建立了派生类的临时对象，对指向基类的指针指向这个临时对象，当用delete运算符撤销对象时，系统执行的是基类的析构函数，而不是派生类的析构函数，不能彻底完成“清理现场”的工作。解决的办法是将基类及派生类的析构函数设为虚函数，这时无论基类指针指的是同一类族中的哪一个类对象，系统会采用动态关联，调用相应的析构函数，对该对象进行清理工作，符合人们的愿望。（基类指针可以指向继承类的对象）

#### 纯虚函数与抽象类：

**class** **类名**

   **{** 

​           **virtual** **返回值类型 函数名（参数表）= 0;** 

​           **......**

   **};**

如果一个类中至少有一个**纯虚函数**，这个类就是为**抽象类**。

##### 抽象类的规则：

（1）抽象类只能作为用作其他类的基类，**不能建立抽象类的对象**。抽象类处于继承层次结构的较上层，一个抽象类自身**无法实例化**，而只能通过继承机制，生成抽象类的非抽象派生类，然后再实例化。

（2）抽象类**不能用作参数类型、函数返回值或显式转换的类型**。

（3）抽象类不能定义对象，但是**可以声明一个抽象类的指针和引用**。通过指针或引用可以指向并**访问派生类对象**，以访问派生类的成员。

（4）抽象类派生出新的类之后，如果派生类给出所有纯虚函数的函数实现，这个派生类就可以声明自己的对象，因而不再是抽象类；反之，如果派生类没有给出全部纯虚函数的实现，这时的派生类仍然是一个抽象类。