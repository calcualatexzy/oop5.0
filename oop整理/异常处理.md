### 异常处理

**异常处理**(exception handling)就是在运行时刻对异常进行检测、捕获、提示、传递等过程。这里的异常是指软件异常。

由于异常处理机制使得异常的引发和处理不必在同一函数中;

​		底层的函数可以着重解决具体问题而不必过多地考虑对异常的处理；

​		上层调用者可以在适当的位置设计对不同类型异常的处理。

![1687846919989](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1687846919989.png)

#### 异常处理的实现：

##### 抛掷异常的程序段

```c++
……
throw  表达式;
（异常抛出）
……

```

**捕获并处理异常的程序段**

```c++
try

   复合语句（保护段）

catch（异常类型声明）

    复合语句（处理段）

catch（异常类型声明）

    复合语句（处理段）

……
```

结合：

```c++
throw 表达式;

try-catch的结构为

try

      {被检查的语句} 

catch(异常信息类型 [变量名])

      

{进行异常处理的语句}
```

若有异常则通过throw操作创建一个异常对象并抛出；

将可能抛出异常的程序段嵌在try块之中。控制通过正常的顺序执行到达try块，然后执行try子块内的保护段；

如果在保护段执行期间没有引发异常，那么跟在try子块后的catch子句就不执行。程序继续执行紧跟在try块中最后一个catch子句后面的语句；

catch子句按其在try块后出现的顺序被检查。类型匹配的catch子句将捕获并处理异常（或继续抛出异常）；

如果找不到匹配的处理代码，则自动调用标准库函数terminate，其默认功能是调用abort( )终止程序。

##### 异常处理的执行过程

①控制通过正常的顺序执行到达try语句，然后执行try块内的保护段。

②如果在保护段执行期间没有引起异常，那么跟在try块后的catch语句就不执行，程序从异常被抛掷的try块后跟随的最后一个catch语句后面的语句继续执行下去。

③如果在保护段执行期间或在保护段调用的任何函数中(直接或间接的调用)有异常被抛掷，则从通过**throw创建的对象**中创建一个异常对象(**隐含调用一个拷贝构造函数**)，程序转到**catch处理段** 。 

编译器能够处理抛掷类型的异常，在更高执行上下文中寻找一个catch语句(或一个能处理任何类型异常的catch处理程序)。catch处理程序按其在try块后出现的顺序被检查。如果没有找到合适的处理程序，则继续检查下一个动态封闭的try块。此处理继续下去，直到最外层的封闭try块被检查完。

④如果匹配的catch处理器未找到，则terminate()将被自动调用，而函数terminate()的默认功能是调用abort终止程序。

⑤如果找到了一个匹配的catch处理程序，且它通过值进行捕获，则其形参通过拷贝异常对象进行初始化。如果它通过引用进行捕获，则参量被初始化为指向异常对象，在形参被初始化之后，“循环展开栈”的过程开始。这包括对那些在与catch处理器相对应的try块开始和异常丢弃地点之间创建的(但尚未析构的)所有自动对象的析构。 



catch处理程序的出现顺序很重要，因为在一个try块中，异常处理程序是按照它出现的顺序被检查的。只要找到一个匹配的异常类型，后面的异常处理都将被忽略。

C++异常处理块中，比较特殊的是**catch(...)**，它可以捕获任何异常，在它首发的情况下，其它的catch语句都不被检查。因此，**catch(...)应该放在最后**。

```c++
void main()   
{   
    try  {  	 //异常可能被抛出的代码段	 }        
	catch(…)   //捕获所有异常
	      {  cout<<"exception of everything!"<<endl; }
	 //错误：后面的两个异常处理程序段不会被检查
    catch(const char* str) 
         {  cout<<“exception of:"<<str<<endl;   }
    catch(int& e)
         {  cout<<“exception of type:"<<e<<endl; }
}
```

```c++
【例9-1】处理除零异常
#include <iostream >
using namespace std;
double fun(double a, double b) //定义除法函数  
{  
    if(b==0)  
    {  throw b;  }   //除数为0，抛出异常  
    return a/b;     //否则返回两个数的商  
}  
int main()  
{    
  double res;
  try  //定义异常  
  { res=fun(4,5);  
    cout<<"The result of" <<4<<"/"<<5<<" is : "<<res<<endl;  
    res=fun(6,0); //出现异常，函数内部会抛出异常  
  }  
  catch(double)             //捕获并处理异常  
  { cerr<<"error of dividing zero.\n";  
    exit(1);              //异常退出程序  
  }  
return 0;
} 
```

(1) 首先把可能出现异常的、需要检查的语句或程序段放在try后面的花括号中。

(2) 程序开始运行后，按正常的顺序执行到try块，开始执行try块中花括号内的语句。如果在执行try块内的语句过程中没有发生异常，则catch子句不起作用，流程转到catch子句后面的语句继续执行。

(3) 如果在执行try块内的语句(包括其所调用的函数)过程中发生异常，则throw运算符抛出一个异常信息。**throw抛出异常信息后，流程立即离开本函数，转到其上一级的函数(main 函数)**。throw抛出什么样的数据由程序设计者自定，可以是任何类型的数据。

(4) 这个异常信息提供给try-catch结构，系统会寻找与之匹配的catch子句。

(5) 在进行异常处理后，程序并不会自动终止，**继续执行catch子句后面的语句**。

由于catch子句是用来处理异常信息的，往往被称为catch异常处理块或catch异常处理器。

##### 异常接口声名：

```c++
函数返回值类型 函数名（形参列表）throw（类型列表）；
```

例如：

```c++
double triangle(double,double,double) throw(double);
```

表示triangle函数只能抛出double类型的异常信息。如果写成

```c++
double triangle(double,double,double) throw(int,double,float,char);
```

则表示triangle函数可以抛出int,double,float或char类型的异常信息。异常指定是函数声明的一部分，必须同时出现在函数声明和函数定义的首行中，否则在进行函数的另一次声明时，编译系统会报告“类型不匹配”。

如果在声明函数时未列出可能抛出的异常类型，则该函数可以抛出任何类型的异常信息。

如果想声明一个不能抛出异常的函数，可以写成以下形式:

```c++
double triangle(double,double,double) throw();//throw无参数
```



#### 构造函数、析构函数与异常处理

C++异常处理的真正能力不仅在于能处理各种不同类型异常，还在于**它具有在异常抛掷前为构造的所有局部对象自动调用析构函数的能力**。

在程序中，找到一个匹配的catch异常处理后，如果catch语句的异常类型声明是一个**值参数**，则其初始化方式是复制被抛掷的异常对象；如果catch语句的异常类型声明是一个**引用**，则其初始化方式是使该引用指向异常对象。

当catch语句的异常类型声明参数被初始化后，栈的展开过程便开始了。这包括从对应的try块开始到异常被抛掷处之间对构造（且尚未析构）的所有自动对象进行析构。析构的顺序与构造的顺序相反。然后程序从最后一个catch处理之后开始恢复执行。

构造函数中发生异常后，异常处理遵从以下规则：

(1) 如果对象有成员函数，且如果在外层对象构造完成之前有异常抛出，则在发生异常之前，执行构造成员对象的析构函数。

(2) 如果异常发生时，对象数组被部分构造，则只调用已构造的数组元素的析构函数。

(3) 异常可能跳过通常释放资源的代码，从而造成资源泄漏。解决的方法是，请求资源时初始化一个局部对象，发生异常时，调用析构函数并释放资源。

(4) 要捕捉析构函数中的异常，可以将调用析构函数的函数放入try块，并提供相应类型的catch处理程序块。抛出对象的析构函数在异常处理程序执行完毕后执行。



用不带操作数的throw表达式可将当前正被处理的异常再次抛掷;

这样的表达式只能出现在**一个catch处理程序中**或**catch处理程序内部调用的函数**中。再次抛掷的异常对象是**源异常对象**(不是拷贝)

```c++
     try
     {           throwCSomeOtherException();         }
     catch(...)    //处理所有异常
     {
           //对异常作出响应(也许仅仅是部分的)
           //...
           throw;   //将异常传给某个其它处理器
     }
```

说明:

(1) 被检测的函数必须放在try块中，否则不起作用。

(2) try块和catch块作为一个整体出现，catch块是try-catch结构中的一部分，必须紧跟在try块之后，不能单独使用，在二者之间也不能插入其他语句。但是在一个try-catch结构中，可以只有try块而无catch块。即在本函数中只检查而不处理，把catch处理块放在其他函数中。

(3) try和catch块中必须有用花括号括起来的复合语句，即使花括号内只有一个语句，也不能省略花括号。

(4) 一个try-catch结构中只能有一个try块，但却可以有多个catch块，以便与不同的异常信息匹配。

(5) catch后面的圆括号中，一般只写异常信息的类型名， 如

```c++
catch(double)
```

catch只检查所捕获异常信息的类型，而不检查它们的值。因此如果需要检测多个不同的异常信息，应当由throw抛出不同类型的异常信息。

异常信息可以是C++系统预定义的标准类型，也可以是用户自定义的类型(如结构体或类)。如果由throw抛出的信息属于该类型或其子类型，则catch与throw二者匹配，catch捕获该异常信息。

catch还可以有另外一种写法，即除了指定类型名外，还指定变量名，如

```c++
catch(double d)
```

此时如果throw抛出的异常信息是double型的变量a，则catch在捕获异常信息a的同时，还使d获得a的值，或者说d得到a的一个拷贝。什么时候需要这样做呢？有时希望在捕获异常信息时，还能利用throw抛出的值，如

```c++
catch(double d)

  {cout<<″throw ″<<d;}
```

这时会输出d的值(也就是a值)。当抛出的是类对象时，有时希望在catch块中显示该对象中的某些信息。这时就需要在catch的参数中写出变量名(类对象名)。

#### 异常匹配

从基类可以派生各种异常类，当一个异常抛出时，异常处理器会根据异常处理顺序找到“最近”的异常类型进行处理。如果catch捕获了一个指向基类类型异常对象的指针或引用，那么它也可以捕获该基类所派生的异常对象的指针或引用。相关错误的多态处理是允许的。

