### C++基础

C++程序由注释、编译预处理和程序主体组成。

#### 命名空间namespace

1.命名空间标识符名在所定义的域中必须是唯一的；
2.命名空间作用域不能以分号结束；
3.命名空间可以在全局作用域或其他作用域（另一个命名空间）内部定义，但不能在函数或类内部定义；
4.命名空间和类、结构体类似，但不能实例化，只能引用；
5.命名空间的成员都是公有的，不能对它们私有化；
6.一般在命名空间中声明函数，而在命名空间之外定义函数；
7.命名空间可以嵌套

#### 引用

1.引用是变量的别名，必须在定义时进行初始化，不能在定义完后再赋值
2.一个引用名只能是一个变量的别名，不能再次将它指定为其他变量的别名
3.不能建立引用的引用。
4.不能建立引用数组，也不能建立数组的引用。
5.可以建立指针的引用，但不能创建指向引用的指针
6.当函数返回一个引用时，return语句只能返回一个变量，而不能返回一个表达式
7.不能有NULL引用，一旦引用被初始化，就不能改变引用的关系

#### 函数

1.函数原型不必包含参数的名字，而只要包含参数的类型。下面的函数原型声明是合法的。`int add(int ,int );`
2.函数重载应满足：函数名相同，函数的返回值类型可以相同也可以不同，但参数表必须不同。
即：各函数的参数表中的参数个数或类型必须有所不同
3.重载时编译器无法确定是调用函数f(int& x)，还是调用函数f(int x)，产生二义性。
4.函数申明中可以定义默认参数，申明时从右到左，调用时从左到右
5.当函数的重载带有默认参数时，要注意避免二义性。例如：定义如下两个重载函数：
`double add(double x,double y=2.2);`
`double add(double x);`
这是错误的，因为如果有调用函数add(2.5)时，编译器将无法确定调用哪一个函数。
6.内联函数是一种以空间换时间的方案,在类内定义的成员函数被默认为内联函数

#### const常量

1.const常量必须在定义时初始化
2.`extern const int i；`     //合法
`extern const int i=10；`  //非法，常量不可以被再次赋值

#### new delete

1.`p=new int[10](0);`  // 错误，不能对动态分配的数组进行初始化

### 类与对象

1.在缺省的情况下，结构中的成员（数据成员、成员函数）都是公有的（public），谁都可以访问这些成员。
2.在C++中，由于类是一种数据类型，系统不会为其分配存储空间，所以不能在类声明中给数据成员赋初值。
3.当成员函数的函数体内容较简短时直接在类体内定义,被默认为内联函数。
4.若在类外定义成员函数，一定要加上作用域限定符“::”

内联函数体内不能含有循环语句和switch语句
inline void Perimeter();  //内联函数声明
在类外给出函数体定义的成员函数，若要定义为内联函数，必须加上关键字inline。

类是对象的抽象，而对象是类的实例
只有定义了类的对象后，系统才为其对象分配存储空间。
对象只能访问其的公有（public）成员

构造函数
1.构造函数没有返回值类型，也不能指定为void。
2.默认构造函数：不含有参数，也不会对数据成员进行初始化
3.在定义对象时要注意避免二义性。例如：Date(int y=2012,int m=1,int d=1); Date();
4.构造函数也可以采用构造初始化列表的方式对数据成员进行初始化Date::Date(int y,int m,int d):year(y),month(m),day(d)

析构函数
1.具有static属性的对象在函数调用结束时该对象并不释放，因此也不调用析构函数。只在main函数结束或调用exit函数结束程序时，其生命期将结束，这时才调用析构函数。
2.用new运算符动态地建立了一个对象，当用delete运算符释放该对象时，调用该对象的析构函数。
3.析构函数没有参数、没有返回值，而且不能重载。
4.一个类有且仅有一个析构函数，且应为public。
5.如果没有定义析构函数，系统会自动生成一个默认的析构函数，这个析构函数不做任何事情。

一般情况下，调用析构函数的次序正好与调用构造函数的次序相反，也就是最先被调用的构造函数，其对应的析构函数最后被调用，而最后被调用的构造函数，其对应的析构函数最先被调用。

数组名[下标].成员函数(实参列表);
Box a[3]={             //定义对象数组
     Box(),      //调用构造函数Box，用默认参数初始化第1个元素的数据成员
     Box(15,18,20),   //调用构造函数Box，提供第2个元素的实参
     Box(16,20,26)    //调用构造函数Box，提供第3个元素的实参
    };

静态成员函数没有this指针。

拷贝构造函数
1.对象的赋值只对其中的数据成员赋值
2.类的数据成员中不能包括动态分配的数据，否则在赋值时可能出现意想不到的严重后果。
3.通过赋值方式进行初始化的过程，实际上是通过类的拷贝构造函数来完成的。
4.构造函数名(类名  &);  拷贝构造函数的参数采用引用方式。
每个类都必须有一个拷贝构造函数。如果类中没有定义，则系统会自动生成一个默认拷贝构造函数

调用拷贝构造函数的情况有三种：
 （1）明确表示由一个对象初始化另一个对象。
 （2）当对象作为函数实参传递给函数形参时。
 （3）当对象作为函数的返回值，创建一个临时对象。

1.类的形参列表应该由对象成员所需形参和本类基本类型数据成员所需形参两部分组成。
2.先调用内嵌对象构造函数，再调用本类构造函数。析构调用顺序相反。

**类的静态成员**
类的成员分为：
静态成员：类属性，存储在静态区
非静态成员：对象属性，存储在动态栈区
1.静态数据成员是类的所有对象共享的数据成员，而不是某个对象的数据成员。
2.静态数据成员的初始化工作只能在类外，并且在对象生成之前进行。
3.静态数据成员的初始化与一般数据成员初始化不同，其格式为：
          数据类型 类名::静态数据成员=初始化值;
静态数据成员初始化在类体外进行，而且前面不加static

静态数据成员在类外需要通过类名对它进行访问。
静态数据成员的访问形式为：
类名::静态数据成员;(公有)
也可以通过对象名访问，对象名访问形式为：
对象名.静态数据成员;(公有)

**静态成员函数**
静态成员函数为操作静态成员而设置。

静态成员函数的声明格式为：
     static 返回类型 静态成员函数名(参数表);
定义静态成员函数的格式（不加static）：
    函数类型 类名::静态成员函数名(参数表) 
静态成员函数不属于某一对象，它与任何对象都无关，因此它**没有this指针**，**不能访问类的默认非静态成员**（包括非静态数据成员和非静态成员函数），只能访问本类中的静态成员（包括静态数据成员和静态成员函数）。
可以通过传参同类对象间接访问非静态数据成员。
Point::f1(P1);  //静态成员函数调用时不用对象名

**友元**
友元机制实现类外数据共享
将一个函数声明为一个类的友元函数后，它不但可以通过对象名访问类的公有成员，而且可以通过对象名访问类的私有成员和保护成员。

非成员函数（普通函数）作为友元函数
友元函数为非成员函数，一般在类中进行声明，在类外进行定义；

类的成员函数作为友元函数
通常需要class Time;	//前向引用声明
一个类的成员函数作为另一个类的友元函数的语句格式为：
    friend 返回值类型 类名::函数名（参数表）；

由于友元函数不是类的成员函数，所以对友元函数指定访问权限无效，因此可以把友元函数的说明放在private，public，protected的任意段中。

声明友元类的语句格式为：
        friend class 类名;
友元类的所有成员函数将都成为友元函数。
```
class DateFriend;  		 //前向引用声明
class Date    
{ 
 private:
    int month;
    int day;
    int year;
 public:
    Date(int m,int d,int y) ;
    friend class DateFriend; 		//定义友元类
};

```
1.友元关系具有单向性。
2.友元关系不具有传递性。

**作用域**
如果类的成员函数中定义了与类作用域内变量同名的另一个变量，那么在函数作用域内，函数作用域内的变量将隐藏类作用域内的变量。

**常量对象**
常量对象的特点是它的数据成员的值在对象的整个生存期内都不能被修改。在定义常对象时必须进行初始化。

1.常量成员函数
常量成员函数的定义要使用const关键字，其定义格式为：
   <返回值类型> 函数名（参数表）const;
说明：
（1）const是函数类型的一部分，在实现部分也要带该关键字。
（2）const关键字可用于对重载函数的区分。
（3）常量成员函数不能更新类的数据成员的值，也不能调用该类中没有用const修饰的成员函数，只能调用常量成员函数。
常量对象不能调用非常量成员函数
非常量对象优先调用非常量成员函数

2.常量数据成员
构造函数对该数据成员进行初始化，只能通过初始化列表进行。

3.常量引用 不能通过常量引用改变原对象值，但原对象值可变。

4.常量指针与指向常量的指针
常量指针
int * const w=&x;
    表明w为一个指向int类型的变量x的常量指针。
不能改变常量指针指向的变量
可以改变常量指针指向变量的值 *w = 2.5;

指向常量的指针
const int *w;
表明w为一个指向const int类型的指针，它指向一个整型常量，这个常量的值不能被改变，但w指向的变量可以被改变，即指针所指向的地址可以被改变。

当类中有指针数据成员时，并且为其开辟了空间，浅拷贝会出现问题.
需要自己实现拷贝构造函数完成深拷贝。

### 继承与派生

### 多态性

### 模板

### 文件和流

### 异常处理

### C++高级主题
