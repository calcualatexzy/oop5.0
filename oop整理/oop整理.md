### C++基础

C++程序由注释、编译预处理和程序主体组成。

#### 命名空间namespace

1.命名空间标识符名在所定义的域中必须是唯一的；
2.命名空间作用域不能以分号结束；
3.命名空间可以在全局作用域或其他作用域（另一个命名空间）内部定义，但不能在函数或类内部定义；
4.命名空间和类、结构体类似，但不能实例化，只能引用；
5.命名空间的成员都是公有的，不能对它们私有化；
6.一般在命名空间中声明函数，而在命名空间之外定义函数；
7.命名空间可以嵌套

#### 引用

1.引用是变量的别名，必须在定义时进行初始化，不能在定义完后再赋值
2.一个引用名只能是一个变量的别名，不能再次将它指定为其他变量的别名
3.不能建立引用的引用。
4.不能建立引用数组，也不能建立数组的引用。
5.可以建立指针的引用，但不能创建指向引用的指针
6.当函数返回一个引用时，return语句只能返回一个变量，而不能返回一个表达式
7.不能有NULL引用，一旦引用被初始化，就不能改变引用的关系

#### 函数

1.函数原型不必包含参数的名字，而只要包含参数的类型。下面的函数原型声明是合法的。`int add(int ,int );`
2.函数重载应满足：函数名相同，函数的返回值类型可以相同也可以不同，但参数表必须不同。
即：各函数的参数表中的参数个数或类型必须有所不同
3.重载时编译器无法确定是调用函数f(int& x)，还是调用函数f(int x)，产生二义性。
4.函数申明中可以定义默认参数，申明时从右到左，调用时从左到右
5.当函数的重载带有默认参数时，要注意避免二义性。例如：定义如下两个重载函数：
`double add(double x,double y=2.2);`
`double add(double x);`
这是错误的，因为如果有调用函数add(2.5)时，编译器将无法确定调用哪一个函数。
6.内联函数是一种以空间换时间的方案,在类内定义的成员函数被默认为内联函数

#### const常量

1.const常量必须在定义时初始化
2.`extern const int i；`     //合法
`extern const int i=10；`  //非法，常量不可以被再次赋值

#### new delete

1.`p=new int[10](0);`  // 错误，不能对动态分配的数组进行初始化

### 类与对象

1.在缺省的情况下，结构中的成员（数据成员、成员函数）都是公有的（public），谁都可以访问这些成员。
2.在C++中，由于类是一种数据类型，系统不会为其分配存储空间，所以不能在类声明中给数据成员赋初值。
3.当成员函数的函数体内容较简短时直接在类体内定义,被默认为内联函数。
4.若在类外定义成员函数，一定要加上作用域限定符“::”

内联函数体内不能含有循环语句和switch语句
inline void Perimeter();  //内联函数声明
在类外给出函数体定义的成员函数，若要定义为内联函数，必须加上关键字inline。

类是对象的抽象，而对象是类的实例
只有定义了类的对象后，系统才为其对象分配存储空间。
对象只能访问其的公有（public）成员

构造函数
1.构造函数没有返回值类型，也不能指定为void。
2.默认构造函数：不含有参数，也不会对数据成员进行初始化
3.在定义对象时要注意避免二义性。例如：Date(int y=2012,int m=1,int d=1); Date();
4.构造函数也可以采用构造初始化列表的方式对数据成员进行初始化Date::Date(int y,int m,int d):year(y),month(m),day(d)

析构函数
1.具有static属性的对象在函数调用结束时该对象并不释放，因此也不调用析构函数。只在main函数结束或调用exit函数结束程序时，其生命期将结束，这时才调用析构函数。
2.用new运算符动态地建立了一个对象，当用delete运算符释放该对象时，调用该对象的析构函数。
3.析构函数没有参数、没有返回值，而且不能重载。
4.一个类有且仅有一个析构函数，且应为public。
5.如果没有定义析构函数，系统会自动生成一个默认的析构函数，这个析构函数不做任何事情。

一般情况下，调用析构函数的次序正好与调用构造函数的次序相反，也就是最先被调用的构造函数，其对应的析构函数最后被调用，而最后被调用的构造函数，其对应的析构函数最先被调用。

数组名[下标].成员函数(实参列表);
Box a[3]={             //定义对象数组
     Box(),      //调用构造函数Box，用默认参数初始化第1个元素的数据成员
     Box(15,18,20),   //调用构造函数Box，提供第2个元素的实参
     Box(16,20,26)    //调用构造函数Box，提供第3个元素的实参
    };

静态成员函数没有this指针。

拷贝构造函数
1.对象的赋值只对其中的数据成员赋值
2.类的数据成员中不能包括动态分配的数据，否则在赋值时可能出现意想不到的严重后果。
3.通过赋值方式进行初始化的过程，实际上是通过类的拷贝构造函数来完成的。
4.构造函数名(类名  &);  拷贝构造函数的参数采用引用方式。
每个类都必须有一个拷贝构造函数。如果类中没有定义，则系统会自动生成一个默认拷贝构造函数

调用拷贝构造函数的情况有三种：
 （1）明确表示由一个对象初始化另一个对象。
 （2）当对象作为函数实参传递给函数形参时。
 （3）当对象作为函数的返回值，创建一个临时对象。

1.类的形参列表应该由对象成员所需形参和本类基本类型数据成员所需形参两部分组成。
2.先调用内嵌对象构造函数，再调用本类构造函数。析构调用顺序相反。

**类的静态成员**
类的成员分为：
静态成员：类属性，存储在静态区
非静态成员：对象属性，存储在动态栈区
1.静态数据成员是类的所有对象共享的数据成员，而不是某个对象的数据成员。
2.静态数据成员的初始化工作只能在类外，并且在对象生成之前进行。
3.静态数据成员的初始化与一般数据成员初始化不同，其格式为：
          数据类型 类名::静态数据成员=初始化值;
静态数据成员初始化在类体外进行，而且前面不加static

静态数据成员在类外需要通过类名对它进行访问。
静态数据成员的访问形式为：
类名::静态数据成员;(公有)
也可以通过对象名访问，对象名访问形式为：
对象名.静态数据成员;(公有)

**静态成员函数**
静态成员函数为操作静态成员而设置。

静态成员函数的声明格式为：
     static 返回类型 静态成员函数名(参数表);
定义静态成员函数的格式（不加static）：
    函数类型 类名::静态成员函数名(参数表) 
静态成员函数不属于某一对象，它与任何对象都无关，因此它**没有this指针**，**不能访问类的默认非静态成员**（包括非静态数据成员和非静态成员函数），只能访问本类中的静态成员（包括静态数据成员和静态成员函数）。
可以通过传参同类对象间接访问非静态数据成员。
Point::f1(P1);  //静态成员函数调用时不用对象名

**友元**
友元机制实现类外数据共享
将一个函数声明为一个类的友元函数后，它不但可以通过对象名访问类的公有成员，而且可以通过对象名访问类的私有成员和保护成员。

非成员函数（普通函数）作为友元函数
友元函数为非成员函数，一般在类中进行声明，在类外进行定义；

类的成员函数作为友元函数
通常需要class Time;	//前向引用声明
一个类的成员函数作为另一个类的友元函数的语句格式为：
    friend 返回值类型 类名::函数名（参数表）；

由于友元函数不是类的成员函数，所以对友元函数指定访问权限无效，因此可以把友元函数的说明放在private，public，protected的任意段中。

声明友元类的语句格式为：
        friend class 类名;
友元类的所有成员函数将都成为友元函数。
```
class DateFriend;  		 //前向引用声明
class Date    
{ 
 private:
    int month;
    int day;
    int year;
 public:
    Date(int m,int d,int y) ;
    friend class DateFriend; 		//定义友元类
};

```
1.友元关系具有单向性。
2.友元关系不具有传递性。

**作用域**
如果类的成员函数中定义了与类作用域内变量同名的另一个变量，那么在函数作用域内，函数作用域内的变量将隐藏类作用域内的变量。

**常量对象**
常量对象的特点是它的数据成员的值在对象的整个生存期内都不能被修改。在定义常对象时必须进行初始化。

1.常量成员函数
常量成员函数的定义要使用const关键字，其定义格式为：
   <返回值类型> 函数名（参数表）const;
说明：
（1）const是函数类型的一部分，在实现部分也要带该关键字。
（2）const关键字可用于对重载函数的区分。
（3）常量成员函数不能更新类的数据成员的值，也不能调用该类中没有用const修饰的成员函数，只能调用常量成员函数。
常量对象不能调用非常量成员函数
非常量对象优先调用非常量成员函数

2.常量数据成员
构造函数对该数据成员进行初始化，只能通过初始化列表进行。

3.常量引用 不能通过常量引用改变原对象值，但原对象值可变。

4.常量指针与指向常量的指针
常量指针
int * const w=&x;
    表明w为一个指向int类型的变量x的常量指针。
不能改变常量指针指向的变量
可以改变常量指针指向变量的值 *w = 2.5;

指向常量的指针
const int *w;
表明w为一个指向const int类型的指针，它指向一个整型常量，这个常量的值不能被改变，但w指向的变量可以被改变，即指针所指向的地址可以被改变。

当类中有指针数据成员时，并且为其开辟了空间，浅拷贝会出现问题.
需要自己实现拷贝构造函数完成深拷贝。

### 继承与派生
1.公有继承
当类的继承方式为public（公有），基类的公有成员（public）和保护成员（protected）在派生类中保持原有访问属性，其私有成员（private）仍为基类私有

2.私有继承
基类的公有成员（public）和保护成员（protected）被继承后作为派生类的私有成员（private），派生类的其它成员可以直接访问它们。而基类私有成员（private）在派生类中仍不可访问。

3.保护继承
基类的公有成员（public）和保护成员（protected）都以保护成员身份出现在派生类中，而基类的私有成员（private）仍不可访问。

访问声明，可个别调整基类的某些成员，使之在派生类中保持原来的访问属性。
方法：在公有（public）区域添加
              基类名::成员名字;

派生类构造函数执行顺序一般是：先祖先（基类），再客人（内嵌对象），后自己（派生类本身）
派生类析构函数执行顺序与构造函数正好相反

多重继承
二义性问题
派生类类内：访问同名基类成员时将产生二义性问题
派生类类外：通过派生类对象访问同名的基类成员时将产生二义性问题。
解决：使用作用域标识符 使用同名覆盖的原则 虚基类

虚基类一般性声明语法如下：
class <派生类名>: virtual <继承方式> <基类名>
声明了虚基类后，在进一步派生过程中，虚基类的成员和派生类一起维护同一个内存数据拷贝。

在公有继承下，派生类的对象可作为基类的对象使用，但只能使用从基类继承的成员。

Base b;       	
Derived d;    	
Base &r2=d;  
r2并不是d的别名，它只是d中基类部分的别名，r2与d中的基类部分共享同一存储空间。

### 多态性与虚函数
重载多态、强制多态、类型参数化多态和包含多态。

静态多态表现为函数重载和运算符重载
动态多态是通过虚函数实现的

**运算符重载**
操作符所允许的操作数的个数、优先级和结合性不能变。
重载运算符的函数不能有默认参数
重载的操作符必须有一个用户定义的类型作为操作数
 int operator+(int,int);// error: 不能对内置类型重载+

不能重载的操作符
.        (成员访问运算符)
.*       (成员指针访问运算符)
∷       (域运算符)
sizeof   (长度运算符)
?:       (条件运算符)

重载为类的成员函数Complex operator+( Complex  b);
重载为类的友元函数friend Complex operator+(Complex & a, Complex & b);

C++规定，当重载以下的运算符时，必须重载为某个类的成员函数：
   `=、 [ ] 、（）,->`
当重载以下的运算符时，必须是普通函数或友元函数，不能为成员函数：
   `>>、<< `
一般将双目运算符重载为友元函数，单目运算符重载为成员函数。

operator double() {return real;}
转换运算符函数用于将一个类对象转换成内置数据类型或其他类对象。转换运算符成员函数与它要转换成的数据类型具有相同的名字。
第一，转换运算符函数无需实参
第二，转换运算符函数没有返回类型，甚至void 也不行

**虚函数**
virtual 函数类型 函数名(参数表);
1.虚函数的声明只能出现在类声明中的函数原型声明或定义中，在类外定义时不能出现virtual关键字。
2.类的静态成员函数不可以声明为虚函数，因为静态成员函数不受限于某个对象
3.基类的虚函数无论被公有继承多少次，在多级派生类中仍然为虚函数。

如果仅仅是返回类型不同，其余均相同，系统会给出错误信息；若仅仅是函数名相同，而参数的个数、类型或顺序不同，则系统将它作为普通的函数重载，这时将丢失虚函数的特性。

**纯虚函数**
如果一个类中至少有一个纯虚函数，这个类就是为抽象类，通常也称为抽象基类。
1.抽象类只能作为用作其他类的基类，不能建立抽象类的对象。
2.抽象类不能用作参数类型、函数返回值或显式转换的类型。
3.抽象类不能定义对象，但是可以声明一个抽象类的指针和引用。
4.如果派生类没有给出全部纯虚函数的实现，这时的派生类仍然是一个抽象类
### 模板

### 文件和流

### 异常处理

### C++高级主题
